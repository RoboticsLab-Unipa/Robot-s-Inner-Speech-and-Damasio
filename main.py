# coding=utf-8
"""
    Simulation of reviewed Damasio's emotional model with Morin's Inner Speech model in Pepper Robot.

    (C) 2022 Sophia Corvaia, University of Palermo, Palermo, Italy
    Released under GNU Public License (GPL)
    Contacts: sophia.corvaia@unipa.it
"""
from threading import Event
from random import choice
from time import sleep
from typing import Tuple, Any

from model.SensorState import SensorState
from model.SensoryRepresentation import SensoryRepresentation
from model.Knowledge import Knowledge
from model.Emotion import Emotion
from model.InnerVoice import InnerVoice
from model.Action import Action
from utils.Logger import Logger
from sys import exc_info
from NaoQi.API import lang_supported

from xml.etree.ElementTree import parse

# Global parameters
configuration = {"bodyLanguageMode": "contextual"}  # Gesture configuration in animated speech
wait_seconds = 0  # Seconds in time for sleep function
cycle_reason = 1  # Cycle number to reason about emotion
choose_body_part = True  # Choosing one single body part to reason
no_action = True


def run(data: dict, signals: dict = None, event: Event = None, robot: bool = False, speak: bool = False,
        show: bool = False, step: int = 3, ontology: str = None, language: str = 'en') -> Tuple[Any, Any]:
    """Running Damasio's emotion model based on Inner Speech.

    :param language: Language for robot speaker
    :param ontology: Ontology file for retrieve information from knowledge base
    :param data: Input data
    :param signals: Signals handling update graphic window
    :param event: Event object to control thread execution from GUI
    :param robot: If robot interface is used
    :param speak: If robot speak loudly
    :param show: If robot show emotion reaction
    :param step: Emotional last step for stop execution after unchanged emotion
    """
    if type(data) is not dict:
        raise TypeError('Incorrect type search parameter! Required dict. Received {} instead!'.format(type(data)))

    if language not in lang_supported.keys():
        raise ValueError(f"{language} input language not supported for Aldebaran Robot! "
                         f"Supported languages! {lang_supported}")

    text_sig = emo_sig = mod_sig = exc_sig = fin_sig = None

    if signals:  # Extract graphic signals
        if type(signals) is not dict:
            raise TypeError("Incorrect type signals parameter! Required dict. Received {} instead!".format(type(dict)))
        text_sig = signals['text_signal']
        emo_sig = signals['emo_signal']
        mod_sig = signals['mod_signal']
        exc_sig = signals['exc_signal']
        fin_sig = signals['fin_signal']

    log = Logger(signal=text_sig)  # Initialize Log with graphic

    try:
        onto = Knowledge(ontology, language=language)  # Initialize knowledge base handle

        fields = list(data.keys())
        keys = onto.get_input_classes(name=True)
        for field in fields:
            if field not in keys:
                raise ValueError("Invalid Key search element <{}>! List of allowable keys: {}".format(field, keys))

        ss = SensorState(onto)  # Initialize model elements
        sr = SensoryRepresentation(onto, hermit=False)  # Use Pellet reasoner
        iv = InnerVoice(onto, configuration, log=log, robot=robot, speak=speak, lang=language)  # Initialize Inner Voice
        emo = Emotion(onto, iv=iv)  # Initialize Emotion handler
        act = Action(onto)  # Initialize action system reaction

        previous_emotional_state = []  # Previous emotional state during reasoning loop
        ignore_input = []  # Unchanged Input parameters to be ignored in reasoning
        ignore_body = []  # Unchanged Body parameters to be ignored in reasoning
        r_data = {}  # Retrieved data at current interation
        prev_data = data  # Data at previous iteration. Initialize with data input
        body_reaction = []  # Retrieved body reaction from data input

        # Iterate the process until there is no newer object to retrieve from knowledge or cycle reason is not None
        global cycle_reason
        while prev_data != r_data and cycle_reason:
            log.info('Received: {}'.format(str(data)))
            sleep(wait_seconds)

            if mod_sig:
                mod_sig.emit(0)

            # Create individuals from input in base ontology and synchronize
            individuals = ss.create_instance(data)
            sr.synchronize()
            log.info("Generate SS(I) in knowledge.")
            sleep(wait_seconds)
            log.info("Generated data: {}".format(str(ss.infer_instance(individuals))))
            sleep(wait_seconds)


            log.info("Entering state S1: Retrieve reactions generated by I in SR(I).")
            sleep(wait_seconds)

            if not body_reaction:
                reactions = []  # Retrieve reactions generate by input data based on ontology
                for individual in individuals:
                    reactions = reactions + sr.get_reactions(individual)
                body_reaction = sr.evaluate_reaction(reactions)

            log.info("Evaluated body reactions in P(SR(I)).")
            sleep(wait_seconds)
            log.info("Body reactions: " + str(body_reaction))
            sleep(wait_seconds)

            emotion = sr.evaluate_emotion(body_reaction)  # Evaluate the closest emotion to reactions
            emotion_label = emotion['Selected']
            # emotion_data = emotion['Data']
            emotion_intensity = emotion['Intensity']

            log.info("Selected emotion: found {}".format(emotion_label.upper()))
            sleep(wait_seconds)

            if emo_sig is not None:  # Update graphics emotional info with images and text
                emo_sig.emit(emotion_label)


            if show:  # Body Loop
                sentence = emo.emotion_react(onto.get_class_by_name(emotion_label))
                log.info("Robot says: " + sentence)
                sleep(wait_seconds)
                log.info("External feeling in S.")
                sleep(wait_seconds)
                log.info("Generate SS(S) in knowledge.")
                sleep(wait_seconds)

            # As If Body Loop
            body_reaction = sr.sort_body_reactions(body_reaction)
            # Retrieve reactions and select only unchanged body part between previous reasoning loop
            not_ignored_body = sr.get_body_not_ignored(ignore_body, list(body_reaction))
            body_reaction = {k: v for k, v in body_reaction.items() if k in not_ignored_body}
            log.info("As If Body Loop: Retrieve body parts involved by emotion in SR(S).")
            sleep(wait_seconds)

            log.info("Entering state S2: Received SS(I) and SR(S).")
            sleep(wait_seconds)

            if not body_reaction:  # Normal activation for every body reactions
                sentence_act = onto.get_inner_act('NoReaction')
                log.info(sentence_act)
                sleep(wait_seconds)
                iv.produce(sentence_act)
                break

            log.info("Relevant reactions: " + str(body_reaction))
            sleep(wait_seconds)

            if choose_body_part:  # Choose single body part randomly
                choose_part = list(body_reaction.items())[0]
                # choose_part = choice(list(body_reaction.items()))
                body_reaction = {choose_part[0]: choose_part[1]}  # Convert tuple to dict

            for body in body_reaction:  # Reasoning about feeling in body part
                log.info("-- Reason about " + body.upper() + " body part --")
                sleep(wait_seconds)

                r_reactions = sr.retrieve_reaction(body, body_reaction[body])  # Retrieve reaction associate with body
                log.info("Retrieved Reactions: " + str(r_reactions))
                sentence = iv.think(body, reactions=r_reactions)
                sentence_act = onto.get_inner_act('Why')

                log.info("Robot says: " + sentence)
                iv.produce(sentence)
                log.info("Robot says: " + sentence_act)
                iv.produce(sentence_act)

                # Retrieve causes and select only unchanged causes between previous reasoning loop
                r_causes = sr.get_parameters_not_ignored(ignore_input, sr.retrieve_causes(individuals, r_reactions))
                log.info("Retrieved Causes: " + str(r_causes))


                if not r_causes:  # Ignoring all parameters
                    sentence_act = onto.get_inner_act('NoCauses')
                    log.info(sentence_act)
                    sleep(wait_seconds)
                    iv.produce(sentence_act)
                    r_data = prev_data  # Exit reasoning
                    break

                sentence = iv.think(body, causes=r_causes)
                sentence_act = onto.get_inner_act('WhatAction')

                log.info("Robot says: " + sentence)
                iv.produce(sentence)

                if no_action:
                    log.info("No action needed. Exit cycling")
                    ss.erase_ontology()
                    return emotion_label.upper(), emotion_intensity

                log.info("Robot says: " + sentence_act)
                iv.produce(sentence_act)

                actions = []
                for item in r_causes + r_reactions:  # Retrieve actions associated with reactions and input causes
                    actions = actions + sr.get_actions(item)
                log.info("Actions available: " + str(actions))
                sleep(wait_seconds)
                if not actions:
                    sentence_act = onto.get_inner_act('ActionNotPerformed')
                    log.info("Robot says: " + sentence_act)
                    iv.produce(sentence_act)
                    if not cycle_reason:
                        log.info("Skip to next body reaction.")
                        continue  # Skip to next body reaction
                    else:
                        log.info("Cycle ended. Exit from reasoning")
                        cycle_reason = None
                        break

                selected_action = choice(actions)  # Select random available action
                log.info("Selected action: " + str(selected_action))
                sleep(wait_seconds)
                sentence = onto.get_comment(selected_action)
                log.info("Robot says: " + sentence)
                iv.produce(sentence)

                # Try to perform action
                parameter, value = act.do_action(selected_action, name=data[selected_action.isActionOf.name])
                log.info("Find {} parameter with {} value!".format(parameter, str(value)))
                sleep(wait_seconds)

                if not value:  # Ignore input parameter from reasoning
                    ignore_input.append(parameter)
                    log.warning("IGNORE INPUT: {} input parameter must be ignored!".format(parameter))
                    sentence_act = onto.get_inner_act('NoAction')
                    log.info("Robot says: " + sentence_act)
                    iv.produce(sentence_act)
                else:
                    if parameter in body_reaction.keys():  # Update body reaction value based on action and reiterate
                        log.info("Changing body part " + parameter + " by " + str(value) + " value!")
                        activation = sr.change_body(body_reaction[parameter], value)
                        if not activation:
                            log.warning("IGNORE BODY PART: {} body part parameter must be ignored!".format(parameter))
                            ignore_body.append(parameter)
                            break
                        body_reaction[parameter] = activation
                    else:  # Update data input value based on action and reiterate from beginning
                        log.info("Changing parameter " + parameter + " by " + str(value) + " value!")
                        sleep(wait_seconds)
                        r_data = {k: v for k, v in data.items() if k not in [parameter]}
                        r_data[parameter] = ss.change_input(parameter, value, data[parameter])
                        # Ignore input parameter if there are no changes from the last loop
                        if r_data[parameter] == data[parameter]:
                            log.warning("IGNORE INPUT: {} input parameter must be ignored!".format(parameter))
                            ignore_input.append(parameter)
                            break
                        prev_data = data
                        data = r_data
                        body_reaction = []  # Empty body reactions variable for the next emotion evaluation
                        sleep(wait_seconds)
                        if cycle_reason:
                            log.info("Cycle ended. Exit from reasoning")
                            cycle_reason = None
                    break
            if event and event.is_set():
                break
        if fin_sig:
            fin_sig.emit()
        print("Execution stopped!")

    except Exception as ex:
        ex_type, _, ex_traceback = exc_info()
        lineno = ex_traceback.tb_lineno
        log.error("Exception type {} on line {}: {}".format(ex_type, lineno, ex))
        if exc_sig:
            exc_sig.emit()
        exit(0)


# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    pass
